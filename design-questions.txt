Do we allow states to have names other than integers?

	Sure, why not? Note that at the moment the compose function creates states
	whose names are tuples of the corresponding states in the supplied wfsts.
	I'm not sure if there are future performance disadvantages with this
	though. Will it make much of a difference if the compiler can tell what
	types the states take on? I guess it depends on the operations that the Fst
	package ends up implementing. 

What order do we give the fields of the Wfst type? What order do we give the
arguments of add_arc?

	For add_arc, opted to go for from_state, to_state, input, output, weight.

Should we have a transition matrix, or simply a vector that contains tuples
that correspond to certain arcs?

	For now, decided it makes more sense to just include a vector of rules. The
	former would have only served to aid lookup of weights. It isn't clear that
	this is what is needed (we might be more concerned in lookup of other
	things), so the extra work isn't worth it. Instead I'm just going with a
	set of tuples, as per the WFST formalism.

Do we need to create a dictionary to map state names, inputs and outputs into
indices for lookup in the transitions matrix, or can we just lookup the index
each time?

	See above, at the moment there won't be any transition matrix.

How do we make good unit tests for this?

	For functionality shared with OpenFst it would be worth looking into their
	tests and perhaps just ripping them off completely.

What functionality are we aiming for? Design with that in mind.

	My immediate practical requirements for the paper are a weighted
	finite-state transducer type, an FSA type (for linear chains), a
	composition operator and methods to perform forward filtering / backward
	sampling.

	Basic other operations include functions to create graphical
	representations using Graphviz, perhaps tying this into IJulia some way in
	the spirit of IPython.Display (not sure where IJUlia is on this front yet).
	This would be great for prototyping.

	Also, fundamental operations listed on the FST wikipedia page and OpenFst/Pyfst
	should be included.

How should finite state acceptors be implemented?

	In OpenFst they're just WFSTs where the input and output labels are set to
	be the same. I'm not sure if that's what we should go with here but it's a
	reference point.

How should we name the fields of the Fst? With greek names in line with the
formal construction, or longer human readable names?

	For now, going with human readable names. It can all be changed later if
	need be.

How does our type hierarchy work?

	I think for the moment there won't be a type hierarchy. I'm starting with a
	Wfst type. I might need to make an Fsa/Wfsa type for linear chains,
	otherwise they could just be instances of the Fst type where input/output
	labels are the same.
	
	Worth noting is that there are some general graph algorithms coming into
	the package (such as topological sort algorithm so far). I'm not sure if
	there should be an abstract 'Graph' type that these sorts of methods
	operate on.

In composition, do we need to get rid of arcs and nodes that can't get to the
final state (ie. the "dead ends")?

	I suspect it won't be a problem for forward-backward sampling but it would
	be good to include code to trim these at some point. Otherwise it would
	probably cause problems with other algorithms and is inconsistent with what
	OpenFst/Pyfst do.

What should the name of the package be called?

	Probably Fst.jl since it's consistent with OpenFst and PyFst but using the
	Julia naming convention. (Unfortunately it seems like this means we can't
	have an Fst type, so for that I'm going with Wfst).

Should quotes be put around node sub-names in tuples in wfst2dot?

	Perhaps not, but it's like that for now.

What assertions and other checks should be in place to ensure that the FSTs
make sense?

What should the initial and final weights default to? Is it okay for them to
have no weight?

If I add support for arbitrary semirings, what constraints do I need to put on
them?

What standard should I adhere to for referring to nodes/edges
states/arcs/rules? At the moment it's a bit all over the place.

Perhaps making each rule a type would help readability (we're doing a lot
of indexing on the rule tuples). So we could have edge.input, edge.output,
edge.weight, edge.from, edge.to.
